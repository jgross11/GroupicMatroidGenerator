<html>
    <title>
        Groupic Matroid Generator
    </title>

    <body>
        <label for="mod">Enter mod</label><br>
        <input type="number" id = "mod" value = 1 min = 1 step = 1><br>

        <input type="radio" id = "addition" name = "operator"> 
        <label for="addition">Addition</label><br>

        <input type="radio" id = "multiplication" name = "operator">
        <label for="multiplication">Multiplication</label><br>

        <input type="radio" id = "MG" name = "independence"> 
        <label for="MG">Generate M(G)</label><br>

        <input type="radio" id = "M*G" name = "independence">
        <label for="M*G">Generate M*(G)</label><br>

        <input type="button" id = "generateGroupicMatroid" value="Generate groupic matroid" onclick="generateGroupicMatroid()">
        
        <script>
            
            

            function generateGroupicMatroid(){
                let mod = document.getElementById("mod").value;
                let operator = document.getElementById("addition").checked ? modAddition : document.getElementById("multiplication").checked ? modMultiplication : null;
                let independence = document.getElementById("MG").checked ? MIndependenceNotion : document.getElementById("M*G").checked ? MStarIndependenceNotion : null;
                
                if(isNaN(mod) || operator == null || independence == null){
                    console.log("bad input");
                    return;
                }
                // lame
                let e = operator === modAddition ? 0 : 1;
                let groundSet = [];
                for(let i = 0; i < mod; i++){
                    groundSet.push(parseInt(i));
                }
                console.log("ground set before trimming");
                console.log(groundSet);
                // eliminate identity and involutions
                /*
                for(let i = 0; i < groundSet.length; i++){
                    let val = groundSet[i];
                    if(!independence(val, val, mod, e, operator)){
                        //groundSet.remove(val);
                        i--;
                    }
                };
                */

                console.log("ground set after trimming");
                console.log(groundSet);

                /*
                        some weird idea of trimming dependent elements, although this is
                        not easily done with a variable independence notion...
                
                let independentElements = [];
                for(val1 in groundSet){
                    let independent = true;
                    for(val2 in groundSet){
                        if(!independence(val1, val2, mod, e, operator)){
                            independent = false;
                            break;
                        }
                    }
                    if(independent){
                        let dupe = false;
                        for(val3 in independentElements){
                            if(val3 == val1){
                                dupe = true;
                                break;
                            }
                        }
                        if(!dupe){
                            console.log(val1);
                            independentElements.push(val1);
                        }
                    }
                }
                */
                let independentCollection = [];
                independentCollection.push([]);
                let numberOrderOneElements = (mod - 2 + mod % 2);
                let maxIndependentCollectionOrder = numberOrderOneElements / 2;
                console.log("####");
                console.log("collection before loop");
                printCollection(independentCollection);
                console.log("####");
                
                for(let index = 0; index < independentCollection.length; index++){
                    console.log("####");
                    console.log("collection at start of loop");
                    printCollection(independentCollection);
                    console.log("####");
                    let set = independentCollection[index];
                    console.log("#######");
                    console.log("independent set");
                    console.log(set);
                    console.log("#######");
                    for(let groundSetElement in groundSet){
                        let unionedSet = union(set, groundSetElement);
                        //console.log("unioned set:");
                        //console.log(unionedSet);
                        if(!setEquality(set, unionedSet) && isSetIndependent(unionedSet, independence, mod, e, operator) 
                        && !isSetInCollection(unionedSet, independentCollection)){
                            printCollection(independentCollection);
                            independentCollection.push(unionedSet);
                            printCollection(independentCollection);
                        }
                    }
                }
                console.log("I = ");
                printCollection(independentCollection);
                console.log("|I| = " + independentCollection.length);
            }  

            function isSetInCollection(set, collection){
                console.log("checking if");
                printCollection(collection);
                console.log("in");
                printCollection(collection);
                for(let setIndex = 0; setIndex < collection.length; setIndex++){
                    let testSet = collection[setIndex];
                    if(setEquality(set, testSet)){
                        console.log(set);
                        console.log("in");
                        printCollection(collection);
                        return true;
                    }
                }
                console.log(set);
                console.log("not in");
                printCollection(collection);
                return false;
            }

            function printCollection(collection){
                // TODO print all elements of collection for realtime debugging
                let result = "{";
                for(let x in collection){
                    if(collection[x] == ""){
                        result += "{}, ";
                    }else{
                        result += "{"+collection[x]+"}, ";
                    }
                }
                result += "}";
                console.log(result);
            }

            function isSetIndependent(set, independenceFunction, mod, identity, operator){
                //console.log("checking if set is independent");
                for(let index1 = 0; index1 < set.length; index1++){
                    let val1 = set[index1];
                    for(let index2 = index1; index2 < set.length; index2++){
                        let val2 = set[index2];
                        if(!independenceFunction(val1, val2, mod, identity, operator)){
                            console.log(val1 + " " + val2 + " dependent pair");
                            return false;
                        }
                    }
                }
                console.log(set);
                console.log("is independent");
                return true;
            }

            function union(set, val){
                let copy = [];
                for(let i = 0; i < set.length; i++){
                    copy.push(set[i]);
                }
                for(let x = 0; x < set.length; x++){
                    let y = set[x];
                    console.log(y);
                    if(y == val){
                        return set;
                    }
                }
                copy.push(parseInt(val));
                return copy;
            }

            function setEquality(A, B){
                
                console.log("checking if set");
                console.log(A);
                console.log("equals");
                console.log(B);
                
                if(A.length != B.length){
                    console.log("set equality false, order difference");
                    return false;
                }
                let count = {};
                for(let index = 0; index < A.length; index++){
                    count[A[index]] = count[A[index]] != null ? count[A[index]]+1 : 1; 
                    count[B[index]] = count[B[index]] != null ? count[B[index]]+1 : 1;  
                    console.log(count);
                }
                let keys = Object.keys(count);
                for(key in keys){
                    if(count[keys[key]] != 2){
                        console.log("count[" + keys[key] + "] " + "= " + count[keys[key]]);
                        console.log("set equality false, same order, different elements");
                        return false;
                    }
                }
                console.log("set equality true");
                console.log("");
                return true;
            }

            function MIndependenceNotion(a, b, mod, identity, op){
                /*
                console.log(a);
                console.log(b);
                console.log(mod);
                console.log(identity);
                */
                if(a == identity || b == identity) return false;
                return op(a,b, mod) != identity;
            }

            function MStarIndependenceNotion(a, b, mod, identity, op){
                return a != b && op(a,b, mod) != identity;
            }

            function modAddition(a, b, n){
                return  (a + b) % n;
            }

            function modMultiplication(a, b, n){
                return (a * b) % n;
            }

        </script>
    </body>
</html>